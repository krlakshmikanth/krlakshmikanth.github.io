---
layout: post
title: Vibe Coding - Navigating the AI assisted software landscape
tag:
- code-generation
- ai-code-generator
- ai-code
- ai
- vibe-coding
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ZsMipf0eSEy2WdXzQgsjdA.jpeg" /><figcaption>A herd of cows in the Maikal Hills, Chhattisgarh, India</figcaption></figure><p>Before we dive into what “Vibe Coding” is all about, it feels right to first pause and <strong>thank the researchers and engineers</strong> behind the incredible LLM (Large Language Model) technology. This tech is powering solutions across an array of problems, from boosting productivity and enabling rapid validation to facilitating smoother migrations and effective modernisation. While I might jest that it’s running the world without pressure, patience, and creativity, I am wholeheartedly grateful to the technologists behind Generative AI. As an engineer who works with cloud, data, and AI engineering solutions, I see its potential first-hand.</p><p>Let’s get straight to the point: <strong>Vibe Coding is the practice of using AI to write software based on human-augmented prompts, often in a conversational pattern</strong>. Think of it like a chatbot, but one that possesses the intelligence to write code for you based on the context and information you share. It has significantly more potential than a standard business-facing chatbot which might only respond to user queries related to a particular business; for example, a chatbot typically can’t help you debug, deploy, or maintain a software system.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Zdv76EGy93AqVsMG8Xo0wQ.jpeg" /><figcaption>A brown and white cow grazing in a green grassy field under daylight.</figcaption></figure><p>From my experience, I’ve learned that it’s incredibly important to <strong>follow best practices</strong> when you engage in Vibe Coding with AI code generators to steer clear of common pitfalls. Here are some of the key practices I try to stick to:</p><ul><li><strong>Start with clarity and context</strong>: Before you even ask the AI to write software, make sure you have some documentation in place. <strong>Create a convention, a PRD (Product Requirements Document), and application work/user flows</strong>. Define your code standards and tech stack if you have them in mind. This upfront effort helps the AI stay aligned with your preferences and prevents confusion down the line.</li><li><strong>Divide and conquer</strong>: Don’t try to solve everything at once. <strong>Break down problems into small chunks and manageable, testable steps</strong>. Always start small. Instead of asking the AI to build a complete app in one go, tackle features one at a time.</li><li><strong>Communication is key</strong>: Chat with the code generators just like you would with your colleagues. <strong>Ask the AI to explain the approach it plans to follow</strong>. Choose the simplest approach, especially one you understand and prefer. Encouraging the AI to ask questions is crucial to avoid later confusion. Also, make use of any <strong>custom instructions or rules</strong> that the AI code generators allow you to set.</li><li><strong>Adopt the R-U-Ready framework?</strong>: This framework involves <strong>reviewing, understanding, and assessing the readiness of the generated code for progression</strong>. <strong>Do not blindly accept</strong> the code the generator provides. <strong>Keep it simple by asking for information until you get clarity</strong> on the code before integrating it into your system. It’s also important to get an architectural overview of the application and primarily <strong>comment the code for maintainability</strong>.</li><li><strong>Embrace pair coding techniques</strong>: Use version control diligently. Make <strong>atomic commits</strong> for easier code maintenance and debugging. Utilise live debugging tools to understand and fix issues as they arise. If you encounter problems, <strong>bring them back into the conversation with the AI for troubleshooting</strong>.</li><li><strong>Save done and tested prompts</strong>: To speed up your workflow and ensure consistency, <strong>save the prompts that worked well for future use</strong>. Store them as templates and consider exchanging them with others — it’s a great way to learn.</li><li><strong>Trust but verify</strong>: AI-generated code can look perfect, but it’s vital to <strong>verify and test it rigorously before using it in a real-life application</strong>. Pay special attention to edge cases and potential security concerns.</li><li><strong>Feedback matters</strong>: After using AI-generated code, <strong>understand what worked and what didn’t</strong>. Document this knowledge and bring it back into future conversations with the AI for better code generation next time. You can also <strong>ask the AI to write test cases and supplement them</strong> as needed, especially for critical functionality.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*OlU5XzWjDWOmt3twACQXVw.jpeg" /><figcaption>Boys swimming alongside buffaloes.</figcaption></figure><p>As an additional note, I’ve found that using voice software (speech-to-text apps) to interact with the AI can make the process simpler and easier. It allows for a more natural flow and can be particularly enjoyable for builders who prefer speaking over typing.</p><p>Vibe Coding, when approached with these practices, can be a powerful addition to an engineer’s toolkit, enabling more efficient and potentially more creative development workflows.</p><p>Photo Credits: <a href="https://unsplash.com/@nickhil">Nick</a>, <a href="https://unsplash.com/@wietsej">Wietse</a>, <a href="https://unsplash.com/@miguel_alonso">Miguel</a> from <a href="https://unsplash.com/">Unsplash</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=88d6e9880beb" width="1" height="1" alt="">
